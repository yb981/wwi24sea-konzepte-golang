
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>calculator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">test/calculator/calculator/calculator.go (61.9%)</option>
				
				<option value="file1">test/calculator/calculator/main.go (33.3%)</option>
				
				<option value="file2">test/calculator/calculator/stack.go (84.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// calculator.go
// RPN Calculator
//
// Author: Lukas Gröning
// Date: 22.02.2025
//
// Ein Reverse Polish Notation (RPN) Taschenrechner mit grundlegenden Rechenoperationen,
// Unterstützung für eine LaTeX-Ausgabe, basierend auf einem Stack.

package main

import (
        "fmt"
        "math"
        "os"
        "strconv"
)

// calculator definiert den Hauptrechner mit einem Stack für Zahlen, Verlauf und LaTeX-Ausdrücke
// numberStack speichert aktuelle Eingabewerte
// history speichert die bisherigen Rechenausdrücke in Textform
// latex speichert die bisherigen Eingaben umgewandelt in LaTeX-Form.
type calculator struct {
        numberStack Stack[float64]
        history     Stack[string]
        latex             Stack[string]
}

// checkInput verarbeitet den Benutzereingabe-String und entschiedet,
// ob es sich um einen Befehl oder Operation oder eine Zahl handelt.
func (c *calculator) checkInput(input string) <span class="cov8" title="1">{
        // Befehle
        switch input </span>{
        case "exit":<span class="cov0" title="0">
                fmt.Println("\nQuitting Application. See you soon!")
                os.Exit(0)</span>
        case "latex":<span class="cov0" title="0">
                fmt.Println("\\["+c.latex.Top()+"\\]")
                return</span>
        case "help":<span class="cov0" title="0">
                c.printWelcomeMessage()
                return</span>
        }

        // Operationen und Nummern
        <span class="cov8" title="1">switch input </span>{
        case "+", "-", "*", "/", "^":<span class="cov8" title="1">
                c.performBinaryOperation(input)</span>
        case "abs", "sqrt", "log", "!":<span class="cov8" title="1">
                c.performUnaryOperation(input)</span>
        case "++", "**":<span class="cov0" title="0">
                c.performMultiOperation(input)</span>
        default:<span class="cov0" title="0">
                c.handleNumberInput(input)</span>
        }
}

// performBinaryOperation führt eine binäre Operation mit den obersten zwei Stackwerten druch
func (c *calculator) performBinaryOperation(op string) <span class="cov8" title="1">{
        if len(c.numberStack) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Error: Need at least 2 numbers on the stack.")
                return
        }</span>

        <span class="cov8" title="1">latex2 := c.latex.Pop()
        latex1 := c.latex.Pop()

        term2 := c.history.Pop()
        term1 := c.history.Pop()

        secondOp := c.numberStack.Pop()
        firstOp := c.numberStack.Pop()

        var result float64

        switch op </span>{
        case "+":<span class="cov8" title="1">
                result = firstOp + secondOp
                c.latex.Push(fmt.Sprintf("({%s} + {%s})", latex1, latex2))</span>
        case "-":<span class="cov8" title="1">
                result = firstOp - secondOp
                c.latex.Push(fmt.Sprintf("({%s} - {%s})", latex1, latex2))</span>
        case "*":<span class="cov8" title="1">
                result = firstOp * secondOp
                c.latex.Push(fmt.Sprintf("({%s} \\cdot {%s})", latex1, latex2))</span>
        case "/":<span class="cov8" title="1">
                result = firstOp / secondOp
                c.latex.Push(fmt.Sprintf("\\frac{%s}{%s}", latex1, latex2))</span>
        case "^":<span class="cov8" title="1">
                result = math.Pow(firstOp, secondOp)
                c.latex.Push(fmt.Sprintf("{%s}^{%s}", latex1, latex2))</span>
        }

        <span class="cov8" title="1">termNew := fmt.Sprintf("(%s %s %s)", term1, op, term2)
        c.history.Push(termNew)
        fmt.Printf("current calculation: %s = %v\n", termNew, result)
        c.numberStack.Push(result)</span>
}

// performUnaryOperation führt eine unäre Operation auf dem obersten Stackwert durch.
func (c *calculator) performUnaryOperation(op string) <span class="cov8" title="1">{
        if len(c.numberStack) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Error: Need at least 1 number on the stack.")
                return
        }</span>

        <span class="cov8" title="1">latex1 := c.latex.Pop()
        term1 := c.history.Pop()
        current := c.numberStack.Pop()

        var result float64

        switch op </span>{
        case "abs":<span class="cov0" title="0">
                result = math.Abs(current)
                c.history.Push(fmt.Sprintf("abs(%s)", term1))
                c.latex.Push(fmt.Sprintf("\\lvert{%s}\\rvert", latex1))</span>
        case "sqrt":<span class="cov8" title="1">
                if current &lt; 0 </span><span class="cov0" title="0">{
                        c.restoreState(term1,latex1,current)
                        fmt.Println("Error:", "Error: Square root is not defined for negative numbers.")
                        return
                }</span>
                <span class="cov8" title="1">result = math.Sqrt(current)
                c.history.Push(fmt.Sprintf("sqrt(%s)", term1))
                c.latex.Push(fmt.Sprintf("\\sqrt{%s}", latex1))</span>
        case "log":<span class="cov0" title="0">
                if current &lt;= 0  </span><span class="cov0" title="0">{
                        c.restoreState(term1,latex1,current)
                        fmt.Println("Error: Logarithm is not defined for zero or negative numbers.")
                        return
                }</span>
                <span class="cov0" title="0">result = math.Log(current)
                c.history.Push(fmt.Sprintf("log(%s)", term1))
                c.latex.Push(fmt.Sprintf("log{%s}", latex1))</span>
        case "!":<span class="cov8" title="1">
                if current &lt; 0 || current != math.Floor(current) </span><span class="cov0" title="0">{
                        c.restoreState(term1,latex1,current)
                        fmt.Println("Error: Factorial is not defined for negative numbers or non-integers.")
                        return
                }</span>
                <span class="cov8" title="1">result = c.factorial(current)
                c.history.Push(fmt.Sprintf("%s!", term1))
                c.latex.Push(fmt.Sprintf("%s!", latex1))</span>
        }
        <span class="cov8" title="1">fmt.Printf("current calculation: %s = %v\n", c.history.Top(), result)
        c.numberStack.Push(result)</span>
}

// perform MutliOperation führt eine Operation über alle Werte auf dem Stack aus (Addition/Multiplikation)
func (c *calculator) performMultiOperation(op string) <span class="cov8" title="1">{
        if len(c.numberStack) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Error: Need at least 2 numbers on the stack.")
                return
        }</span>

        <span class="cov8" title="1">n := len(c.numberStack)

        tempSlice, tempSliceHistory, tempSliceLatex := c.popAndReverse(n)
        
        historyOutput := "("
        latexOutput := "("

        var result float64
        if op == "++" </span><span class="cov8" title="1">{
                result = 0.0
        }</span> else<span class="cov8" title="1"> {
                result = 1.0
        }</span>
        
        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                current := tempSlice[i]
                if op == "++" </span><span class="cov8" title="1">{
                        result += current
                }</span> else<span class="cov8" title="1"> {
                        result *= current
                }</span>
                
                <span class="cov8" title="1">historyOutput += tempSliceHistory[i]
                latexOutput += tempSliceLatex[i]

                if i != n-1 </span><span class="cov8" title="1">{
                        if op == "++" </span><span class="cov8" title="1">{
                                historyOutput += " + "
                                latexOutput += " + "
                        }</span> else<span class="cov8" title="1"> {
                                historyOutput += " * "
                                latexOutput += " \\cdot "        
                        }</span>
                }
        }

        <span class="cov8" title="1">historyOutput += ")"
        latexOutput += ")"

        c.numberStack.Push(result)
        c.history.Push(historyOutput)
        c.latex.Push(latexOutput)
        fmt.Printf("current calculation: %s = %v\n", historyOutput, result)</span>
}

// handleNumberInput verarbeitet die Eingabe, wenn es sich um einen Zahl handelt.
func (c *calculator) handleNumberInput(input string) <span class="cov8" title="1">{
        number, err := strconv.ParseFloat(input, 64)
        if err == nil </span><span class="cov8" title="1">{
                c.numberStack.Push(number)
                c.history.Push(input)
                c.latex.Push(input)
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Error: Wrong Input")
        }</span>
}

// factorial berechnet die Fakultät eines nicht-negativen ganzzahligen Werts.
func (c calculator) factorial(n float64) float64 <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return 1 // 0! is 1
        }</span>
        <span class="cov8" title="1">var result float64 = 1
        for i := 1; i &lt;= int(n); i++ </span><span class="cov8" title="1">{
                result *= float64(i)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// restoreState stellt den vorherigen Zustand des Stacks wieder her, 
// wenn eine Operation fehlschlägt. (Error handling)
func (c *calculator) restoreState(term1 string, latex1 string, currentNumber float64) <span class="cov0" title="0">{
        c.numberStack.Push(currentNumber)
        c.history.Push(term1)
        c.latex.Push(latex1)
}</span>

// popAndReverse entfernt die obersten n Elemente von allen Stacks und gibt sie in umgekehrter Reihenfolge zurück.
func (c *calculator) popAndReverse(n int) ([]float64, []string, []string) <span class="cov8" title="1">{
        tempSlice := make([]float64, n)
        tempSliceHistory := make([]string, n)
        tempSliceLatex := make([]string, n)

        for i := n - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                tempSlice[i] = c.numberStack.Pop()
                tempSliceHistory[i] = c.history.Pop()
                tempSliceLatex[i] = c.latex.Pop()
        }</span>
        <span class="cov8" title="1">return tempSlice, tempSliceHistory, tempSliceLatex</span>
}

// printWelcomeMessage zeigt dem Benutzer eine Übersicht aller Funktionen und Befehle an.
func (c calculator) printWelcomeMessage() <span class="cov0" title="0">{
        fmt.Println("=========================================")
        fmt.Println("        Welcome to the RPN Calculator   ")
        fmt.Println("=========================================")
        fmt.Println("Functionality:")
        fmt.Println(" +  Addition")
        fmt.Println(" -  Subtraction")
        fmt.Println(" *  Multiplication")
        fmt.Println(" /  Division")
        fmt.Println(" ^  Exponentiation")
        fmt.Println(" sqrt  Square Root")
        fmt.Println(" log  Logarithm (Base 10)")
        fmt.Println(" !  Factorial")
        fmt.Println(" abs  Absolute Value")
        fmt.Println(" ++  Sum All Numbers on the Stack")
        fmt.Println(" **  Multiply All Numbers on the Stack")
        fmt.Println()
        fmt.Println("Available Commands:")
        fmt.Println(" - Type 'help' for assistance")
        fmt.Println(" - Type 'latex' for LaTeX formatted output")
        fmt.Println(" - Type 'exit' to close the application")
        fmt.Println()
        fmt.Println("=========================================")
        fmt.Println("Please enter your command:")
}</pre>
		
		<pre class="file" id="file1" style="display: none">// main.go
// Startet das RPN Calculator Programm.
//
// Author: Lukas Gröning
// Date: 22.02.2025

package main

import (
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        calculator := calculator{}

        calculator.printWelcomeMessage()

        for </span><span class="cov0" title="0">{
                calculator.numberStack.Print()

                input := getInput()

                calculator.checkInput(input)
        }</span>
}

// getInput liest die Benutzereingabe von der Konsole ein.
func getInput() string <span class="cov8" title="1">{
        var input string
        _, err := fmt.Scan(&amp;input)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error while reading input: ", err.Error())
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">return input</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">// stack.go
// Generische Stack-Implementierung basierend auf einer verketteten Liste.
//
// Author: Lukas Gröning
// Date: 22.02.2025

package main

import "fmt"

type Stack[T any] []T

func (s *Stack[T]) Push(input T) <span class="cov8" title="1">{
        *s = append(*s, input)
}</span>

func (s *Stack[T]) Pop() T <span class="cov8" title="1">{
        if len(*s) == 0 </span><span class="cov8" title="1">{
                var zero T
                return zero
        }</span>

        <span class="cov8" title="1">lastValue := (*s)[len(*s)-1]
        *s = (*s)[:len(*s)-1]
        return lastValue</span>
}

func (s Stack[T]) Top() T <span class="cov8" title="1">{
        if len(s) != 0 </span><span class="cov8" title="1">{
                return s[len(s)-1]
        }</span>
        <span class="cov8" title="1">var zero T
        return zero</span>
}

func (s Stack[T]) Print() <span class="cov0" title="0">{
        for _, value := range s </span><span class="cov0" title="0">{
                fmt.Print(value, " ")
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
